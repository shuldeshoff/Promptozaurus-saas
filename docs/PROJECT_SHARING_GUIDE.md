# Работа с промптами и совместная работа в PromptyFlow

## Оглавление

1. [Текущий функционал](#текущий-функционал)
2. [Механизм расшаривания проектов](#механизм-расшаривания-проектов)
3. [Проблемы текущего подхода](#проблемы-текущего-подхода)
4. [Предложения по оптимизации](#предложения-по-оптимизации)
5. [Почему НЕ экспорт/импорт JSON](#почему-не-экспортимпорт-json)
6. [Облачный подход vs Десктопный](#облачный-подход-vs-десктопный)
7. [Roadmap внедрения](#roadmap-внедрения)

---

## Текущий функционал

### Что есть сейчас

**Проекты:**
- Пользователь создает проект
- В проекте хранятся промпты и блоки контекста
- Проекты приватные (видны только владельцу)
- Можно расшарить проект с другим пользователем по email

**Промпты:**
- Создаются внутри конкретного проекта
- Привязаны к проекту
- Нельзя переиспользовать в других проектах
- Нельзя создать "общую библиотеку" промптов

**Контекст:**
- Блоки контекста привязаны к проекту
- Можно разбивать на под-элементы
- Full-text search по содержимому

**Поиск:**
- Глобальный поиск по всем промптам пользователя
- Работает очень быстро (PostgreSQL GIN индексы)
- Поиск по названию и содержимому

---

## Механизм расшаривания проектов

### Как работает сейчас

**Расшаривание на уровне проекта:**

1. Владелец проекта открывает модальное окно "Проекты"
2. Нажимает иконку "поделиться" у нужного проекта
3. Вводит email пользователя
4. Выбирает уровень доступа (view/edit)
5. Нажимает "Добавить"

**Что происходит:**
- Система проверяет, зарегистрирован ли пользователь с таким email
- Создается запись в БД (таблица project_shares)
- Проект мгновенно появляется в списке проектов получателя
- Получатель может открыть проект и работать с ним (в зависимости от прав)

**Аналогия:**
- Как в Google Docs: поделиться документом по email
- Получатель сразу видит документ в своем списке
- Работает в реальном времени
- Можно отозвать доступ одним кликом

### Технические детали

**База данных:**
```sql
-- Таблица для расшаривания
CREATE TABLE project_shares (
  id TEXT PRIMARY KEY,
  projectId TEXT REFERENCES projects(id) ON DELETE CASCADE,
  sharedWithEmail TEXT NOT NULL,
  permission TEXT NOT NULL, -- 'view' или 'edit'
  createdAt TIMESTAMP DEFAULT NOW()
);

-- Индекс для быстрого поиска
CREATE INDEX project_shares_email_idx ON project_shares(sharedWithEmail);
```

**API endpoints:**
```
POST   /api/projects/:id/share       # Поделиться проектом
DELETE /api/projects/:id/share/:id   # Отозвать доступ
GET    /api/projects/shared          # Получить расшаренные со мной проекты
```

**Безопасность:**
- Все изменения сохраняются в оригинальном проекте
- Владелец видит изменения в реальном времени
- Можно мгновенно отозвать доступ
- Логирование всех действий

---

## Проблемы текущего подхода

### 1. Нет общей библиотеки промптов

**Проблема:**
Представьте, что вы создали отличный промпт для "анализа кода Python". Вы хотите использовать его в 5 разных проектах. Сейчас вам нужно:
1. Открыть проект 1
2. Создать промпт вручную (скопировать-вставить)
3. Повторить для проектов 2, 3, 4, 5

Если вы потом улучшите промпт в проекте 1, в остальных проектах останется старая версия.

**Что хотелось бы:**
- Создать промпт один раз в "библиотеке"
- Использовать его во всех проектах
- Изменение в библиотеке обновляет промпт везде (или предлагает обновить)

---

### 2. Нельзя группировать промпты

**Проблема:**
У вас 50 промптов для работы с кодом: "анализ Python", "рефакторинг JavaScript", "code review Go" и т.д. Все они валятся в один список. Тяжело найти нужный.

**Что хотелось бы:**
- Группировать промпты в "наборы" (например, "Разработка → Python")
- Визуально отделить наборы друг от друга
- Быстро переключаться между наборами

---

### 3. Нет тегов для организации

**Проблема:**
Промпт "Анализ безопасности Python кода" относится одновременно к:
- Категории "Python"
- Категории "Безопасность"
- Категории "Code Review"

Наборы (из п.2) не решают эту проблему, так как промпт может быть только в одном наборе.

**Что хотелось бы:**
- Добавить теги к промптам: #python #security #code-review
- Фильтровать промпты по тегам
- Один промпт может иметь несколько тегов

---

### 4. Сложно делиться отдельными промптами

**Проблема:**
Вы хотите поделиться одним промптом с коллегой, но не хотите давать доступ ко всему проекту. Сейчас можно только:
- Расшарить весь проект (он увидит все промпты и контексты)
- Или скопировать промпт в текстовом виде и отправить по email/Slack

**Что хотелось бы:**
- Поделиться конкретным промптом
- Или поделиться набором промптов
- Получатель может импортировать их в свою библиотеку

---

## Предложения по оптимизации

### Концепция 1: Библиотека промптов (Template Library)

**Что это:**
Общая библиотека промптов, не привязанная к конкретным проектам. Аналогия: Notion Templates, Figma Components.

**Как работает:**

```
Структура данных:

User
├── Projects (как сейчас)
│   ├── Project 1
│   │   ├── Context blocks
│   │   └── Project-specific prompts
│   └── Project 2
│
└── Template Library (новое!)
    ├── Template 1: "Анализ кода Python"
    ├── Template 2: "Code review checklist"
    └── Template 3: "Bug report generation"
```

**Функционал:**
1. Создать промпт в библиотеке (не в проекте)
2. Использовать промпт из библиотеки в любом проекте
3. При изменении промпта в библиотеке - предлагать обновить везде
4. Можно "отвязать" промпт от библиотеки (станет проектным)

**UI:**
```
Sidebar:
- Мои проекты
- Библиотека промптов  <-- новая секция
  ├── Все промпты
  ├── Избранное
  └── Последние использованные
```

**Преимущества:**
- DRY (Don't Repeat Yourself) для промптов
- Централизованное управление часто используемыми промптами
- Версионирование (можно сохранять историю изменений)

---

### Концепция 2: Наборы промптов (Template Sets)

**Что это:**
Группировка промптов в логические наборы. Аналогия: Плейлисты в Spotify, Коллекции в Pinterest.

**Как работает:**

```
Template Library
├── Набор: "Python Development"
│   ├── "Анализ кода Python"
│   ├── "Рефакторинг Python"
│   └── "Pytest генерация"
│
├── Набор: "Content Writing"
│   ├── "Blog post outline"
│   ├── "SEO optimization"
│   └── "Social media caption"
│
└── Набор: "Customer Support"
    ├── "Email response template"
    └── "Troubleshooting guide"
```

**Функционал:**
1. Создать набор с названием и описанием
2. Добавить промпты в набор (drag & drop)
3. Один промпт может быть в нескольких наборах
4. Можно поделиться целым набором с другим пользователем

**UI:**
```
Библиотека промптов:
- Просмотр: [Все] [По наборам] [По тегам]

По наборам:
┌─────────────────────────────────┐
│ Python Development (8 prompts)  │
│ Content Writing (12 prompts)    │
│ Customer Support (5 prompts)    │
└─────────────────────────────────┘
```

**Связь с проектами:**
- Проект может быть "связан" с набором
- При открытии проекта, промпты из набора подсвечиваются
- Изменения в наборе можно синхронизировать с проектом

---

### Концепция 3: Теги (Tags)

**Что это:**
Метки для промптов, позволяющие многомерную классификацию. Аналогия: Instagram hashtags, Gmail labels.

**Как работает:**

```
Промпт: "Анализ безопасности Python кода"
Теги: #python #security #code-review #senior

Промпт: "Bug report для Python проекта"
Теги: #python #bug-report #qa
```

**Функционал:**
1. Добавить любое количество тегов к промпту
2. Фильтровать промпты по одному или нескольким тегам
3. Автодополнение при вводе тега (показывает существующие)
4. Поиск по тегам очень быстрый (GIN индекс)

**UI:**
```
Фильтры:
┌─────────────────────────────────┐
│ Теги: [#python] [#security]     │
│                                 │
│ Найдено: 8 промптов             │
└─────────────────────────────────┘

Облако тегов:
#python (24)  #javascript (18)  #code-review (15)
#security (12)  #bug-report (8)  #senior (7)
```

**Преимущества:**
- Один промпт может относиться к нескольким категориям
- Очень гибкая организация
- Пользователь сам создает свою таксономию
- Можно использовать совместно с наборами

---

### Концепция 4: Связь проектов и наборов

**Что это:**
Проект может быть "связан" с одним или несколькими наборами промптов. Аналогия: Figma Libraries в конкретном файле.

**Как работает:**

```
Проект: "Backend API Development"
Связанные наборы:
- "Python Development" (8 промптов)
- "API Design" (5 промптов)
- "Testing" (6 промптов)

Итого: 19 промптов из библиотеки доступны в проекте
```

**Функционал:**
1. В настройках проекта: "Подключить набор"
2. Выбрать набор из библиотеки
3. Промпты из набора становятся доступны в проекте
4. При изменении набора - уведомление в проекте
5. Можно "отписаться" от набора

**UI:**
```
Настройки проекта:
┌─────────────────────────────────┐
│ Подключенные наборы:            │
│ ✓ Python Development            │
│ ✓ API Design                    │
│ ✓ Testing                       │
│ [+ Подключить набор]            │
└─────────────────────────────────┘

При работе с промптом:
[Мои промпты] [Из библиотеки]
              └── Python Development (8)
              └── API Design (5)
              └── Testing (6)
```

**Преимущества:**
- Быстрый доступ к нужным промптам в контексте проекта
- Не нужно искать по всей библиотеке
- Автоматическое обновление при изменении набора

---

## Почему НЕ экспорт/импорт JSON

### Проблема 1: Уводит пользователя с платформы

**Что происходит с экспортом/импортом:**

```
Пользователь A:
1. Экспортирует набор промптов в JSON
2. Отправляет файл по email/Slack/Telegram
3. Больше не контролирует, что будет с данными

Пользователь B:
4. Получает JSON файл
5. Импортирует в свою систему
6. Теперь у него своя копия
7. Изменения не синхронизируются с пользователем A

Проблемы:
- Данные покинули платформу
- Нет связи между оригиналом и копией
- Нет контроля версий
- Нет аналитики использования
```

**Почему это плохо для SaaS:**

1. **Network Effect разрушается:**
   - SaaS платформы зависят от того, что пользователи работают ВНУТРИ платформы
   - Экспорт данных = выход из платформы
   - Чем больше данных покидает платформу, тем меньше ценность сервиса

2. **Нет метрик:**
   - Вы не знаете, кто использует ваши промпты
   - Нет статистики популярности
   - Нельзя порекомендовать похожие промпты
   - Нет основы для монетизации (marketplace)

3. **Нет контроля:**
   - Пользователь может выложить ваш JSON на GitHub
   - Любой может использовать без регистрации
   - Нет возможности отозвать доступ
   - Нет возможности обновить промпт у всех пользователей

---

### Проблема 2: Раскрывает формат данных

**Что происходит:**

```json
// export.json
{
  "version": "1.0",
  "templates": [
    {
      "id": "abc123",
      "name": "Code Review Prompt",
      "content": "Review this code and suggest improvements...",
      "tags": ["code-review", "python"],
      "settings": {
        "temperature": 0.7,
        "maxTokens": 2000
      }
    }
  ]
}
```

**Почему это проблема:**

1. **Конкуренты могут скопировать структуру:**
   - Видят ваши таблицы БД
   - Видят формат данных
   - Могут создать совместимый импорт/экспорт
   - Пользователи легко мигрируют к конкуренту

2. **Реверс-инжиниринг API:**
   - JSON файл показывает, какие поля используются
   - Можно понять логику работы системы
   - Легче создать клоны

3. **Нет защиты интеллектуальной собственности:**
   - Если у вас есть уникальные AI-паттерны в промптах
   - Экспорт делает их доступными всем
   - Нет DRM, нет защиты

---

### Проблема 3: Ломает синхронизацию

**Сценарий:**

```
День 1:
- Пользователь A создает промпт "Code Review v1"
- Экспортирует в JSON
- Отправляет пользователю B

День 2:
- Пользователь A улучшает промпт → "Code Review v2"
- Пользователь B все еще использует v1
- Нет уведомления об обновлении

День 30:
- У пользователя A версия v10
- У пользователя B версия v1
- Они даже не знают, что используют разные версии
```

**Проблемы:**
- Нет единого источника правды (Single Source of Truth)
- Фрагментация данных
- Сложно поддерживать актуальность
- Пользователи работают с устаревшими данными

**Как это решается в облаке:**
```
Облачное расшаривание:
- Пользователь A создает промпт
- Расшаривает с пользователем B
- Пользователь B видит ту же версию
- А обновляет → Б видит обновление
- Всегда синхронизировано
```

---

### Проблема 4: Характерно для десктопа, не для SaaS

**Desktop подход (старая модель):**

```
Photoshop (десктоп):
1. Создаешь .psd файл
2. Сохраняешь на диске
3. Отправляешь коллеге по email
4. Коллега открывает у себя
5. Вносит изменения
6. Отправляет обратно
7. Conflict resolution вручную

Это нормально для десктопа, потому что:
- Нет постоянного интернета (2000-е годы)
- Нет облачного хранилища
- Нет collaborative editing
- Файл = единица работы
```

**SaaS подход (современная модель):**

```
Figma (SaaS):
1. Создаешь дизайн в облаке
2. Шаришь ссылку с коллегой
3. Коллега открывает ту же ссылку
4. Видит изменения в реальном времени
5. Может комментировать
6. История версий автоматически
7. Нет конфликтов

Это лучше, потому что:
- Всегда онлайн (2020-е годы)
- Collaborative editing из коробки
- Single Source of Truth
- Ссылка = единица шаринга
```

**Примеры SaaS, которые НЕ используют экспорт/импорт для шаринга:**

| Сервис | Как шарят | Есть ли экспорт? | Для чего экспорт? |
|--------|-----------|------------------|-------------------|
| **Google Docs** | Ссылка или email | Да (.docx, .pdf) | Для офлайн работы, печати |
| **Figma** | Ссылка | Да (.fig, .png) | Для презентаций, хэндофф |
| **Notion** | Ссылка или email | Да (.md, .pdf) | Для бэкапов, миграции |
| **Trello** | Ссылка или email | Да (.json) | Для бэкапов, миграции |
| **Miro** | Ссылка | Да (.pdf, .png) | Для презентаций |

**Паттерн:**
- Основной способ шаринга: ОБЛАЧНЫЙ (ссылка/email внутри платформы)
- Экспорт есть: ДА, но для ДРУГИХ целей (бэкап, миграция, печать)
- Экспорт НЕ используется для collaborative work

---

### Проблема 5: Нет монетизации

**Как SaaS зарабатывают на расшаривании:**

**Freemium модель (Notion, Figma):**
```
Free tier:
- Можешь шарить с 5 пользователями
- Базовые permissions (view/edit)

Paid tier:
- Можешь шарить с неограниченным числом пользователей
- Расширенные permissions (admin, custom roles)
- Audit logs (кто что изменил)
- Версионирование
```

**Marketplace модель (Figma, Notion):**
```
1. Пользователь создает крутой набор промптов
2. Публикует в Marketplace
3. Другие пользователи платят за доступ
4. Платформа берет комиссию (20-30%)

Примеры:
- Figma Community: дизайн-системы, иконки
- Notion Templates: шаблоны для работы
- GPT Store: кастомные GPT модели
```

**С экспортом/импортом:**
```
1. Пользователь создает крутой набор промптов
2. Экспортирует в JSON
3. Выкладывает на GitHub бесплатно
4. Все скачивают без регистрации
5. Платформа не зарабатывает НИЧЕГО
```

---

## Облачный подход vs Десктопный

### Сравнительная таблица

| Критерий | Десктопный подход (экспорт/импорт) | Облачный подход (расшаривание) |
|----------|-----------------------------------|-------------------------------|
| **Шаринг** | Экспорт JSON → email → импорт | Ссылка или email в платформе |
| **Синхронизация** | Вручную (re-export/re-import) | Автоматическая (real-time) |
| **Версионирование** | Нет (или вручную) | Автоматическое (история изменений) |
| **Контроль доступа** | Нет (файл = полный доступ) | Гибкий (view/edit/admin) |
| **Отзыв доступа** | Невозможен (файл уже у получателя) | Мгновенный (удалить из списка) |
| **Кто использует** | Узнать невозможно | Полная аналитика |
| **Обновления** | Вручную переотправлять файл | Автоматически для всех |
| **Монетизация** | Невозможна | Freemium, Marketplace |
| **Network effect** | Нет (данные вне платформы) | Есть (данные в платформе) |
| **Конфликты** | Возможны (два пользователя редактируют копии) | Нет (single source of truth) |
| **Офлайн работа** | Да (главное преимущество) | Ограничена |
| **Примеры** | Photoshop (.psd), VS Code (settings.json) | Figma, Google Docs, Notion |

### Когда экспорт/импорт уместен

**Использовать для:**

1. **Бэкапы:**
   - Пользователь хочет локальную копию данных
   - На случай, если сервис закроется
   - Защита от потери данных

2. **Миграция:**
   - Переход с одного сервиса на другой
   - Смена аккаунта
   - Корпоративная миграция

3. **Compliance:**
   - GDPR: право на экспорт данных
   - Корпоративные политики
   - Аудит

4. **Офлайн работа:**
   - Нет интернета (редко в 2025)
   - Работа на самолете
   - Локальная обработка

5. **Интеграция с другими системами:**
   - Импорт в IDE
   - Автоматизация через CI/CD
   - Custom workflows

**НЕ использовать для:**
- Collaborative работы (используйте облачное расшаривание)
- Передачи промптов между пользователями (используйте расшаривание)
- Публикации промптов (используйте marketplace)
- Версионирования (используйте встроенное версионирование)

---

## Рекомендуемая архитектура

### Уровень 1: Библиотека промптов (основа)

```
User
└── Template Library
    ├── Template 1
    ├── Template 2
    └── Template 3

API:
GET    /api/templates              # Все промпты из библиотеки
POST   /api/templates              # Создать промпт в библиотеке
PATCH  /api/templates/:id          # Редактировать
DELETE /api/templates/:id          # Удалить
```

**Приоритет: HIGH (фундамент всей системы)**

---

### Уровень 2: Теги (организация)

```
Template
├── name: "Code Review Prompt"
├── content: "..."
└── tags: ["python", "code-review", "senior"]

API:
GET    /api/templates?tags=python,code-review  # Фильтр по тегам
GET    /api/tags                                # Все теги пользователя
POST   /api/templates/:id/tags                  # Добавить тег
DELETE /api/templates/:id/tags/:tag             # Удалить тег
```

**Приоритет: MEDIUM (повышает usability)**

---

### Уровень 3: Наборы (группировка)

```
User
└── Template Library
    └── Sets
        ├── Set 1: "Python Development"
        │   ├── Template 1
        │   └── Template 2
        └── Set 2: "Content Writing"
            ├── Template 3
            └── Template 4

API:
GET    /api/template-sets          # Все наборы
POST   /api/template-sets          # Создать набор
POST   /api/template-sets/:id/templates/:templateId  # Добавить промпт в набор
DELETE /api/template-sets/:id/templates/:templateId  # Удалить из набора
```

**Приоритет: MEDIUM (для продвинутых пользователей)**

---

### Уровень 4: Расшаривание наборов (collaboration)

```
User A создает набор
↓
Расшаривает с User B
↓
User B видит набор в "Shared with me"
↓
User B может:
- Просмотреть промпты (view permission)
- Использовать в своих проектах
- Скопировать в свою библиотеку (fork)

API:
POST   /api/template-sets/:id/share     # Поделиться набором
DELETE /api/template-sets/:id/share/:id # Отозвать доступ
GET    /api/template-sets/shared        # Наборы, расшаренные со мной
POST   /api/template-sets/:id/fork      # Копировать набор в свою библиотеку
```

**Приоритет: HIGH (ключевой для collaborative work)**

---

### Уровень 5: Marketplace (монетизация)

```
User A создает набор
↓
Публикует в Marketplace
↓
Устанавливает цену ($10) или бесплатно
↓
User B покупает
↓
Набор появляется в его библиотеке
↓
20% комиссии платформе, 80% автору

API:
POST   /api/marketplace/listings        # Опубликовать набор
GET    /api/marketplace/listings        # Все публикации
GET    /api/marketplace/listings/:id    # Детали публикации
POST   /api/marketplace/purchase/:id    # Купить набор
```

**Приоритет: LOW (для будущей монетизации)**

---

### Экспорт/импорт (вспомогательный функционал)

```
Экспорт:
- Для бэкапов
- Для миграции
- Для офлайн работы

НЕ для:
- Шаринга с другими пользователями (используйте cloud sharing)
- Collaborative работы (используйте real-time sync)

API:
GET    /api/templates/export            # Экспорт библиотеки в JSON
POST   /api/templates/import            # Импорт JSON в библиотеку
GET    /api/template-sets/:id/export    # Экспорт набора
POST   /api/template-sets/import        # Импорт набора
```

**Приоритет: LOW (nice to have, но не для основного use case)**

---

## Roadmap внедрения

### Фаза 1: Библиотека промптов (2-3 недели)

**Что делаем:**
1. Создать таблицу `templates` (отдельно от проектов)
2. Создать UI для управления библиотекой
3. Возможность создавать промпты в библиотеке
4. Возможность использовать промпты из библиотеки в проектах

**DB Schema:**
```prisma
model Template {
  id        String   @id @default(cuid())
  userId    String
  name      String
  content   String   @db.Text
  variables Json?    @db.JsonB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}
```

**UI:**
```
Sidebar:
+ Мои проекты
+ Библиотека промптов  <-- новое!
```

**Результат:**
- Пользователи могут создавать переиспользуемые промпты
- DRY для промптов

---

### Фаза 2: Теги (1 неделя)

**Что делаем:**
1. Добавить поле `tags` в таблицу `templates`
2. Создать UI для добавления/удаления тегов
3. Фильтрация по тегам
4. Автодополнение при вводе тега

**DB Schema:**
```prisma
model Template {
  // ... existing fields
  tags      String[] @default([])  // Array of tags
}

// Добавить GIN индекс для быстрого поиска по тегам
CREATE INDEX templates_tags_gin_idx ON "Template" USING gin(tags);
```

**UI:**
```
Template card:
┌─────────────────────────────────┐
│ Code Review Prompt              │
│ #python #code-review #senior    │
└─────────────────────────────────┘

Filters:
[Теги: #python ×] [#code-review ×]
```

**Результат:**
- Легко организовывать промпты
- Быстрый поиск по категориям

---

### Фаза 3: Наборы промптов (2 недели)

**Что делаем:**
1. Создать таблицу `template_sets`
2. Связующая таблица `template_set_items`
3. UI для создания/редактирования наборов
4. Drag & drop для добавления промптов в набор

**DB Schema:**
```prisma
model TemplateSet {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?  @db.Text
  color       String?  @default("#3B82F6")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       TemplateSetItem[]
  
  @@index([userId])
}

model TemplateSetItem {
  id            String      @id @default(cuid())
  setId         String
  templateId    String
  order         Int         @default(0)
  
  set           TemplateSet @relation(fields: [setId], references: [id], onDelete: Cascade)
  template      Template    @relation(fields: [templateId], references: [id], onDelete: Cascade)
  
  @@unique([setId, templateId])
  @@index([setId])
}
```

**UI:**
```
Библиотека промптов:
Просмотр: [Все] [По наборам ✓] [По тегам]

Наборы:
┌─────────────────────────────────┐
│ Python Development (8 prompts)  │
│ [Edit] [Share] [Delete]         │
└─────────────────────────────────┘
```

**Результат:**
- Логическая группировка промптов
- Легко найти нужный набор

---

### Фаза 4: Расшаривание наборов (2 недели)

**Что делаем:**
1. Создать таблицу `template_set_shares`
2. API для расшаривания наборов
3. UI для управления доступом
4. Fork функционал (копирование набора)

**DB Schema:**
```prisma
model TemplateSetShare {
  id              String      @id @default(cuid())
  setId           String
  sharedWithEmail String
  permission      String      // 'view' or 'edit'
  createdAt       DateTime    @default(now())
  
  set             TemplateSet @relation(fields: [setId], references: [id], onDelete: Cascade)
  
  @@unique([setId, sharedWithEmail])
  @@index([sharedWithEmail])
}
```

**UI:**
```
Кнопка "Share" у набора:
┌─────────────────────────────────┐
│ Поделиться набором              │
│ Email: [_________________]      │
│ Права: [View ▼] [Edit]          │
│ [Добавить]                      │
│                                 │
│ Доступ имеют:                   │
│ - john@example.com (edit) [×]   │
│ - jane@example.com (view) [×]   │
└─────────────────────────────────┘
```

**Результат:**
- Collaborative работа над промптами
- Нет необходимости в экспорте/импорте

---

### Фаза 5: Marketplace (опционально, 4+ недели)

**Что делаем:**
1. Public listings таблица
2. Payment integration (Stripe)
3. Модерация контента
4. Рейтинги и отзывы
5. Поиск по маркетплейсу

**Результат:**
- Монетизация платформы
- Экосистема для создателей контента
- Network effect

---

## Итоговое обоснование

### Почему облачное расшаривание лучше экспорта/импорта

**1. User Experience:**
- Один клик vs скачать → отправить → загрузить
- Синхронизация автоматическая
- Нет конфликтов версий

**2. Бизнес:**
- Пользователи остаются в платформе
- Возможна монетизация (freemium, marketplace)
- Network effect

**3. Технически:**
- Single Source of Truth
- Проще поддерживать
- Лучше масштабируется

**4. Безопасность:**
- Контроль доступа
- Возможность отозвать
- Audit logs

### Когда экспорт/импорт нужен

**Обязательно иметь для:**
- Compliance (GDPR right to data portability)
- Бэкапы (пользователи хотят безопасность)
- Миграция (переход между сервисами)

**Но НЕ как основной способ шаринга!**

---

## Заключение

Рекомендуемый подход:

1. **Основной функционал:** Облачное расшаривание
   - Наборы промптов
   - Расшаривание по email
   - Real-time sync
   - Контроль доступа

2. **Вспомогательный функционал:** Экспорт/импорт JSON
   - Для бэкапов
   - Для миграции
   - Для compliance

3. **Будущее:** Marketplace
   - Публичные наборы
   - Платные и бесплатные
   - Рейтинги и отзывы

Этот подход соответствует индустрии SaaS (Figma, Notion, Google Docs) и обеспечивает лучший UX при сохранении контроля над данными и возможности монетизации.

**Последнее обновление:** 05.12.2025  
**Версия:** 2.0  
**Статус:** Рекомендации для внедрения
